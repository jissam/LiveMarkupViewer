import { Participant } from '../../common/types/participant.types';
import { Logger, Observable } from '../../common/utils';
import { IOC } from '../../services/io';
import { RealtimeMessage } from './types';
export declare class Channel extends Observable {
    private name;
    private ioc;
    private channel;
    protected logger: Logger;
    private state;
    private localParticipant;
    private callbacksToSubscribeWhenJoined;
    constructor(name: string, ioc: IOC, localParticipant: Participant);
    disconnect(): Promise<void>;
    /**
     * @function publish
     * @description Publishes an event with optional data to the channel.
     * @param event - The name of the event to publish.
     * @param data - Optional data to be sent along with the event.
     */
    publish: import("lodash").DebouncedFunc<(event: string, data?: unknown) => void>;
    /**
     * @function subscribe
     * @description Subscribes to a specific event and registers a callback function to handle the received data.
     *  If the channel is not yet available, the subscription will be queued and executed once the channel is joined.
     * @param event - The name of the event to subscribe to.
     * @param callback - The callback function to handle the received data. It takes a parameter of type `RealtimeMessage` or `string`.
     */
    subscribe: (event: string, callback: (data: RealtimeMessage | string) => void) => void;
    /**
     * @function unsubscribe
     * @description Unsubscribes from a specific event.
     * @param event - The event to unsubscribe from.
     * @param callback - An optional callback function to be called when the event is unsubscribed.
     */
    unsubscribe: (event: string, callback?: (data: RealtimeMessage | string) => void) => void;
    /**
     * @function changeState
     * @description change realtime component state and publish state to client
     * @param state
     * @returns {void}
     */
    private changeState;
    private subscribeToRealtimeEvents;
    /**
     * @function fetchHistory
     * @description get realtime client data history
     * @returns {RealtimeMessage | Record<string, RealtimeMessage>}
     */
    fetchHistory: (eventName?: string) => Promise<RealtimeMessage[] | Record<string, RealtimeMessage[]> | null>;
    /**
     * @function publishEventToClient
     * @description - publish event to client
     * @param event - event name
     * @param data - data to publish
     * @returns {void}
     */
    private publishEventToClient;
}
